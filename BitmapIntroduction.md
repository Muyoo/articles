title: Bitmap技术简介
comments: true
date: 2017-03-11 11:28:32
updated: 2017-03-11 11:28:32
tags:
- bitmap
- 数据存储
- 算法
categories:
- 技术
- 算法
mathjax: true
---
![夜郎谷是贵阳的一位匠人独自花费20年的时间建立的一座石头古堡。一个人实现自己的梦想到底需要多久？ —— Photo By 潇慕雨](http://7vzs9m.com1.z0.glb.clouddn.com/2017-01-30%20212015.jpg)

## Bitmap简介
### 定义

Bitmap是一种存储元素的算法，这里的bitmap与windows上存储图片的bitmap不是同一个东西。下面是关于本文bitmap的定义：

- 本文所描述的bitmap并不是指Windows下的标准格式图形文件（.bmp或.dib文件）
- 本文的bitmap指大量不重复元素的集合的存储方式以及算法

## Bitmap的存储与操作

### 初步存储

对于一个集合（元素不重复），用一个bit位来标记这个集合中的一个元素。
举例一：
我们有一个元素集合为{1, 3, 4, 7}，那么我们则可以将这4行记录的ID存储在一个8位的bit序列B中：0000 0000,。
对于元素1，将其存储在B中的第1个位置，也就是把B中第1个bit标记为1；对于元素3，将B中的第3个bit标记为1；同理依次将集合中的元素在B中找到起其对应的位置，并将该位置的bit置为1。
<!-- more -->
这样，我们就得到如下的bitmap（Little-Endian，第1位从右边开始数）：

- 对于元素1，0000 0000 → 0000 0001；接着是元素3，0000 0000 → 0000 0101；……；最后得到，0000 0000 → 0100 1101
- 注意
 - 在这个过程中，我们需要强调的是：
  1. 元素是不重复的；
  2. 元素必须能够映射成一个自然数
- 优点
 - 优化了集合的排重操作。对于不同集合间的排重操作，只需要对存储成bitmap后的整数做与或运算即可；在元素数量很多时，排重速度能够得到极大提升；
 - 优化查找集合中元素的操作。当需要查找集合是否存在某个元素时，仅需要将该元素做移位操作生成一个仅有该元素的bitmap，然后将其与查找集合的bitmap做与运算即可；
- 缺点
 - 无法准确存储单一元素所独有的信息。对于一个bitmap集合中的元素，从本质上它们已经被划归到一个整体（关于这一点的进一步解释会在后文提到）

### 进一步存储

好了，到现在我们已经将一个拥有4个元素的集合成功地用一个整数来表示了，数据存储上方面我们至少节省了四分之三的空间！
然而，当我们在实际情况中，往往集合不会对我们这般仁慈只给我们4个元素（或许是残忍？），或是这些元素的ID并不会如此相邻；通常情况下，我们得到的是一个元素很多、元素ID的数字又相

隔较远的集合，也就是一个很长又比较稀疏的bitmap序列，例如当我们往刚才的例子中加入元素1000时，我们的bitmap就变成了：

    0000 0000 0000 0000 0000 0000 1000 0000, ........ , 0000 0100 1101

中间的省略号代表未写出来的928个0，这也是不小的数字，尤其当元素的ID越大时，这种情况越严重。那么，我们怎么将这种bitmap有效存储呢？

#### json格式
##### 存储方式

这种情况下，我们可以考虑使用json格式的方式来存储。这种方式的存储思路，实际上采取的就是“分桶”策略。json的K-V格式数据，K即为某个“桶”的编号、或者说容器的编号，V 就是容器中的容量。

考虑上面的例子，我们加了元素1000后集合变为了{1,3,4,7, 1000}，那么我们可以将这个bitmap划分为若干个区间，而这个区间的长度就是整型数的长度即32个bit（长整型是64）；

然后再将元素对应到它所在的区间，并将对应的bit置为1即可。每个区间的bitma就可以用一个整型数来表示。下面是这个过程的步骤：

1. 取一个元素，将其除以32，得到商m与余数n；
2. m表示该元素在第m个区间内，余数n表示元素在该区间内的第n个bit
3. 将这个bit位通过或运算将其置为1

在例子中，元素1就对应到第0个区间的第1位，元素1000对应到第31个区间的第8位；最终，这个集合被我们表示成一个json对象：{"0":77, "31":128}。
比起我们之前的那么多0，中间那些不必要的0就被去掉了，为我们节省了很大的存储空间！

##### json格式下的“AND”和“OR”操作

对于Bitmap来说，最关键的操作就是与或运算了。那么在json格式下，如何对两个bitmap做与或运算呢：

- 遍历其中一个bitmap的key-value，将查看当前key是否在另一个bitmap中：
 - 若存在，则将value跟另一个bitmap对应的value做与或操作
 - 若不存在，与操作：不处理，遍历下一个key；或操作：直接将该key添加到另一个bitmap中
- 遍历结束，得到一个新的bitmap

##### json格式下的元素数量统计

通常，在得到一个新的bitmap后我们会想要知道这个bitmap集合中有多少个元素。在json格式下，做统计的方式与原始存储方式相同，均需要遍历一次bitmap中所有的bit位。

- 遍历所有的key-value，对于每个value，将其与 1 做与运算：
 - 若结果为1，说明该位当前第1位为1，统计计数+1
 - 若结果为0，则统计计数不变
- 将value右移一位，然后重复上一步操作；
- 最后遍历结束，得到最终的统计计数结果

json格式虽然将bitmap的存储空间大幅地降低了，但其对于统计集合的元素数量并没有优势。而RLE的存储方式则可以弥补这一点。

#### RLE格式
##### 存储方式

RLE（Run Length Enconding），游程编码，又称行程长度编码，是一种压缩编码算法；简单来说，它通过记录序列中某个值和该值连续出现次数来对整个序列进行压缩。
仍然使用刚开始的例子，我们得到的bitmap是0000 1101，则可以表示成1,1,2,4，代表从右边开始，先是连续的1个1，接着是1个0，接着是2个1，接着是4个0。
为了保持统一，我们对RLE稍作变动：让所有的bitmap起始的数字都代表0的个数，即1,1,2,4 → 0,1,1,2,4。
生成RLE格式的bitmap，可以先将json格式的生成，然后通过json格式转换过来。（因为生成json格式数据很容易，然后只需要再通过json的key值计算出中间空出的0的数量即可）

#### RLE格式下的“AND”和“OR”操作

RLE格式下的与或运算比较麻烦，本质上看是需要自己实现与或的操作。基本思路是：

- 对两个bitmap，分别设游标 i 和 j；
- 比较i0 和 j0，先比较标志位0或1。然后比较连续的数量，将较少的压入一个队列中，并得到差值；同时将较少的游标下移指向 i1
- 上一步得到的差值再与 i1 的值进行相同比较过程；
- 最后直到至少一个游标遍历结束，然后将还没有遍历到的部分直接压入队列

这样，我们得到一个存着比较结果的队列，再将队列遍历一次，合并相同标志位的数量即可。若是在压入队列时就合并的话，可以免去这一步遍历操作。
举例：
两个bitmap的与运算，0,2,2,1,2 和 1,1,3。为了方便，我们加上其标志位写成[(0,0), (1, 2), (0,2), (1,1), (0,2)] 和 [(0,1), (1, 1), (0, 3)]，操作过程如下图：
![RLE操作过程](http://7vzs9m.com1.z0.glb.clouddn.com/image2015-2-12%2015-12-56.png)

最后，将队列相同标记位的进行合并，得到最终结果：1,1,5

##### RLE格式下的元素数量统计

由于我们在生成RLE格式数据的时候，对第一位进行了0的对齐，所以对RLE格式数据的统计，只需要将序列中奇数位的数加和即可。

#### json格式与RLE格式对比

json格式对比RLE格式：
- 优点：
 - 生成数据简单；
 - 与或操作、查询元素的操作实现简单；
- 缺点：
 - 数据的压缩比没有RLE高
 - 对集合的统计计数速度没有RLE快

共同的问题是：当集合中的元素id稠密且分布分散时，速度与空间的提升会大打折扣。

### Bitmap在统计分析中的应用

在统计分析中，我们可以利用bitmap的特点降低数据存储、加快排重速度、加快集合计数速度，同时在此基础上也为我们的统计分析提供了快速而灵活的维度组合分析。
首先来看它在实际情况中是怎样降低我们的数据存储空间的。
以本文最初的例子为例 {1, 3, 4, 7}，假设它是代表下面的表：

| ID | Device | Revenue |
|---:|:-------:|:--------:|
|1   |iPhone  |100      |
|3   |iPhone  |300      |
|4   |iPhone  |400      |
|7   |P9      |700      |

这4个ID占了数据库表中的4行记录，而使用bitmap的话，我们则可以这么做：

- 将Device的不同值的ID都划归成该值的一个集合，把这个集合做成一个bitmap。得到iPhone->{1, 3, 4}=0000 1101 与 HTC -> {7}=0100 0000
- 对于Revenue维度，由于在Device维度上已经将ID集合区分开，所以Revenue在每种Device下是可累加的得到 iPhone->800 和 HTC -> 700

这样，我们的数据库表就变成了如下形式：

| Device | Revenue | Bitmap |
|------- |:-------:|--------:|
|iPhone  |800      |0000 1101|
|P9      |700      |0100 0000|

在这里，原来的4行数据就被压缩成了2行。当ID有很多时，能得到更高的压缩比。

当我们的维度很多时，若是传统的存储方式，当我们灵活组合多维度分析时，遇到排重的统计就需要不停对万或者十万级别以上的数据进行排重统计。这样的效率很低。
例如游戏分析中的留存统计，在这样的情况下我们很难做到让用户自由选择时间区间进行统计。因为选择不同的时间区间就意味着我们需要将每天的设备ID集合都取出来，然后一一进行排重。
查询出的记录很多且排重速度慢。
但使用Bitmap的方式，我们则可以取出每天对应的bitmap，若干天也就是若干条记录，查询出的记录数量远远减少。排重的速度也仅是做若干次与或运算即可完成。

### Bitmap特性与应用后记

Bitmap这一技术在目前的很多统计分析中确实有着非常广泛的应用。这也是由它的特性所决定：

- 从统计角度看，它天然具备distinct的效果
- 从存储的角度看，它天然具备压缩的效果，而且压缩效率不错
- 从计算角度看，计算若干个bitmap所需计算操作不多

由于这些特性，bitmap就非常适合现在我们常遇到的海量数据下的统计分析问题。因为在进行数据分析时，各种指标的计算无非两大类：

- 不需要去重、可直接累加的
- 需要去重、不能直接累加的

在需要去重的这一类下，或许细分还有比较特殊的枚举类指标，不过这类较少，能不能算得上一般意义上的“指标”还需另做讨论。
在海量数据时，进行去重统计是最麻烦的，例如用户的留存计算；
如果通过编写SQL来实现这样的功能，即使拥有像Hive这样的分布式利器，要在秒级出结果也是件难事。所以这类指标的统计，还是要换种思路来做。

目前有哪些应用都使用了Bitmap技术呢：

- [Apache Lucene](https://lucene.apache.org/core/)
- [Apache Solr](https://lucene.apache.org/solr/)
- [ElasticSearch](https://www.elastic.com/)
- [Metamarkets’ Druid](http://druid.io/)
- [Apache Spark](https://spark.apache.org/)
- [Apache Kylin](https://kylin.apache.org/)

### 参考

- [Bitmap的秘密](http://www.infoq.com/cn/articles/the-secret-of-bitmap)
- [Better bitmap performance with Roaring bitmaps](https://arxiv.org/pdf/1402.6407.pdf)
